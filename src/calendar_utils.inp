function string numeric_to_extended_iso8601 (const int value "ISO8601 numeric date value")
    /* Cast numeric ISO8601 date (YYYYMMDD) to extended ISO8601 date string.
    In case of an error, an empty string is returned. */

    string date

    catch string date = isodate(epochday(value), 1)
    if $error
        sprintf("ERROR: Numeric value %d cannot be cast to date string.", value)
        return ""
    endif

    return date
end function


function strings iso8601_to_dates (const series dates "Num. ISO8601 date")
    /* Based on a series in numeric iso8601 format, an array of strings in the extended ISO8601 format ("YYYY-MM-DD") is returned. */

    strings ret = array($nobs)

    loop i=1..nelem(ret)
        ret[i] = numeric_to_extended_iso8601(dates[i])
    endloop

    return ret
end function



function series create_iso8601_series (const scalar init_date "numeric ISO8601")
    /* Return series with dates in ISO8601 format. 'init_date' refers to the initial date for the first observation, and the length of the data set determines the following recursive dates. Works for both time-series and panels. */

    if $datatype == 3
        scalar N = $nobs/$pd
        scalar T = $pd
    elif $datatype == 2
        return $obsdate
    else
        funcerr "Data must be either of panel or time-series type."
    endif

    string date_string = sprintf("%d", init_date)
    errorif(strlen(date_string) != 8, "Numeric ISO8601 date must comprise eight digits.")

    scalar init_epoch_date = epochday(init_date)
    scalar last_epoch_date = init_epoch_date + T - 1
    matrix epoch_days_values = seq(init_epoch_date, last_epoch_date)'
    series epoch_days = vec(ones(T, N) .* epoch_days_values)
    series iso_date = isodate(epoch_days, 1)

    return iso_date
end function


function series dates_to_iso8601 (const series dates "Date string",
                                  const string date_format "e.g. %Y-%m-%d")
    /* Transforms a string-valued dates series to the numeric iso8601 format. Works for panel, time-series and cross-sectional data. */

    series iso8601 = NA
    smpl dates --no-missing

    loop i = 1..nobs(dates)
        iso8601[i] = date_to_iso8601(dates[i], date_format)
    endloop

    smpl full

    return iso8601
end function


function scalar date_to_iso8601 (const string date "Date string",
                                 const string date_format "e.g. %Y-%m-%d")
    /* Transforms a date string to the numeric ISO8601 format.
    return: int, Numeric ISO8601 date. */

    print date
    print date_format

    scalar iso8601 = NA
    scalar seconds = strptime(date, date_format)
    iso8601 = atof(strftime(seconds, "%Y%m%d"))

    return iso8601
end function


function scalar is_valid_date_delimiter (const string date)
    /* Check the delimiter of date components.
    return: int, TRUE if valid, otherwise FALSE. */

    if instring(date, ":")
        return TRUE
    endif

    return FALSE
end function


function string get_frequency_label (void)
    /* Retrieve label for given periodicity of the underlying time-series or panel dataset.
    return: string, Frequency label for a given periodicity. */

    if $datatype == 2
        pd = $pd
    elif $datatype == 3
        pd = $nobs / $pd
    else
        funcerr "Dataset must be either of type time-series or panel."
    endif

    if pd == 4
        return "quarterly"
    elif pd == 12
        return "monthly"
    else
        errorif(TRUE, sprintf("Periodicity of the dataset (pd = %d) is not supported.", $pd))
    endif
end function


function scalar gdate_to_iso8601 (string date "Date string",
                                  string frequency[null] "Frequency of observation")
    /* This function supports monthly and quarterly date strings as used and accepted by gretl itself; basically only patterns like "1999:3" or "1999.3".

    return: int, Date string transformed to an integer representing the numeric ISO8601 format. */

    date = strstrip(strsub(date, ".", ":"))
    if exists(frequency)
        frequency = strstrip(tolower(frequency))
    else
        string frequency = get_frequency_label()
    endif

    scalar isok = is_valid_date_delimiter(date)
    errorif(!isok, "Not a recognized gretl date string. Must be of format '%d:%d' or '%d.%d'.")

    strings parts = strsplit(date, ":")
    errorif(nelem(parts) != 2, "Invalid date string input. Must be of format '%d:%d' or '%d.%d'")

    return get_iso_date(parts, frequency)
end function


function scalar get_iso_date (const strings parts,
                              const string frequency)
    /* Compile ISO8601 date integer value from 'parts'.
    return: int, Numeric date in ISO8601 format. */

    first = atof(parts[1])  # atof("01") -> 1
    second = atof(parts[2])

    check_frequency_ranges(first, second, frequency)

    if frequency == "quarterly"                 # construct the ISO output
        out  = first * 10000                    # year
        out += ((second - 1) * 3 + 1) * 100     # first month in quarter
        out += 1                                # first day in month
    elif frequency == "monthly"
        out  = first * 10000
        out += second * 100
        out += 1
    endif

    return out
end function


function void check_frequency_ranges (const int first,
                                      const int second,
                                      const string frequency)
    /* Check value ranges. Error if parameters are out of bounds. */

    if frequency == "quarterly"
        errorif(first < 1000 || first > 9999, "Year out of range")
        errorif(second < 1 || second > 4, "Quarter out of range")
    elif frequency == "monthly"
        errorif(first < 1000 || first > 9999, "Year out of range")
        errorif(second < 1 || second > 12, "Month out of range")
    else
        errorif(TRUE, sprintf("Frequency '%s' not supported.", frequency))
    endif
end function
